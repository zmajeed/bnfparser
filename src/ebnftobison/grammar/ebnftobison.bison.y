// ebnftobison/ebnftobison.bison.y

/*
MIT License

Copyright (c) 2024 Zartaj Majeed

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// bison -Wall -Wdangling-alias -Werror --color=always -Wcounterexamples --report=counterexamples,lookaheads --report-file=bisonreport.txt ebnftobison.bison.y
/* g++ -O0 -Wall -Wextra -Werror -std=c++23 -o ebnftobison ebnftobison.bison.cpp */

// c++ parser classes skeleton file
%skeleton "lalr1.cc"

%require "3.8"

// c++ parser
%language "c++"

// generate parser description report .output file
%verbose

%defines "ebnftobison.bison.h"
%output "ebnftobison.bison.cpp"

// enable debug trace
%define parse.trace

// adds location parameter to symbol constructors
%locations

// generate header for location to be used outside of bison parser
%define api.location.file "locations.bison.h"

%define parse.error detailed

// want to return character token from flex but don't think it can work with api.token.constructor
// better lookup performance at cost of disallowing literal characters in grammar
%define api.token.raw

%code requires {
// %code requires codeblock goes at top of .h outside of namespace and parser class
// standard c++ #includes and defines

#include <string>
#include <functional>
#include <chrono>
#include <map>
#include <set>
#include <vector>

#include "locations.bison.h"

namespace ebnftobison {

using namespace std;
using namespace chrono;

using Production = set<vector<string>>;
using Rule = map<string, set<vector<string>>>;

struct BisonParam {
  struct Stats {
    duration<double> parseTimeTakenSec;
    time_point<steady_clock> parseStartTime;
    time_point<steady_clock> parseEndTime;
    uint64_t numRulesParsed = 0;
    uint64_t numRulesGenerated = 0;
  } stats;
  Rule result;
};

}

}

// custom namespace generated by bison
%define api.namespace {ebnftobison}

// custom classname generated by bison
%define api.parser.class {EbnfToBison}

// parser constructor parameter 1
// this is the yylex bison will call, it can have any signature we want since it's a lambda passed in by the client that wraps and hides the actual yylex call
%parse-param {function<EbnfToBison::symbol_type(location&)> yylex}

%parse-param {BisonParam& bisonParam}

// parser constructor parameter 2
// only because each lex-param also must be parse-param
%parse-param {location& loc}

// yylex parameter 1
// pass location to lexer to update
%lex-param {location& loc}

// use actual types for tokens
%define api.value.type variant

// use c++ objects, changes signature of yylex, yylex now returns EbnfToBison::symbol_type, yylex takes no parameters, change everywhere yylex is referenced, eg parse-param, any lambdas
%define api.token.constructor

%define parse.assert

%code provides {
// %code provides codeblock goes in .h after namespace and parser class
// everything here needs EbnfToBison defined earlier

// parser objects
namespace ebnftobison {

using namespace std;

}

}

%{
// %{ unnamed codeblock goes at very top of .cpp file before parser namespace and class methods

#include <sstream>

%}

%code {
// %code codeblock goes at top of .cpp before parser namespace and class methods

#include <chrono>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <regex>

using namespace std;
using namespace chrono;

namespace {
  const auto defaultInputName = "inputstream"s;
}

void ebnftobison::EbnfToBison::error(const location& loc, const string& msg) {
  bisonParam.result.clear();
  cerr << "error at " << loc << ": " << msg << "\n";
}

}

%initial-action {
// %initial-action codeblock goes inside parse() function in .cpp, it's a separate brace-scoped block, anything declared here is local to this block and cannot be used anywhere else in parse()

  bisonParam.stats.parseStartTime = steady_clock::now();

  if(loc.begin.filename == nullptr) {
    loc.initialize(&defaultInputName);
  }
}

%token COLON_EQUAL          "::="
%token LEFT_BRACKET         "["
%token RIGHT_BRACKET        "]"
%token LEFT_BRACE           "{"
%token RIGHT_BRACE          "}"
%token ELLIPSIS             "..."
%token BAR                  "|"

%token WHITESPACE
%token RULE_SEPARATOR

%token <string> NONTERMINAL
%token <string> TOKEN
%token <string> LITERAL
%token <string> COMMENT
%token <string> HEADER_LINE

%nterm <string> element
%nterm <Production> production
%nterm <Production> concatenation
%nterm <Production> alternative
%nterm <Production> optional
%nterm <Production> repetition
%nterm <Production> group
%nterm <Production> production_combos
%nterm <Rule> rule
%nterm <Rule> rules

%start ebnf

%%

// no code allowed in rules section, just bison comments that are dropped from .cpp

ebnf: header rule {
  bisonParam.result.merge($rule);
} postprocess
| header rule rules {
  bisonParam.result.merge($rule);
  bisonParam.result.merge($rules);
} postprocess
;

rules: RULE_SEPARATOR rule {
  $$ = $rule;
}| rules RULE_SEPARATOR rule {
  $$ = $1;
  $$.merge($rule);
}
;

rule: NONTERMINAL "::=" production_combos {
  ++bisonParam.stats.numRulesParsed;
  auto underscoresName = regex_replace($NONTERMINAL.substr(1, $NONTERMINAL.length() - 2), regex{"[^a-zA-Z0-9_]"}, "_");
  $$ = { {underscoresName, $production_combos} };
}

production_combos: concatenation | alternative | COMMENT {}

production: element {
  $$ = { {$element} };

}
| optional {
  $$ = $optional;
}
| repetition {
  $$ = $repetition;
}
| group {
  $$ = $group;
}
;

element: NONTERMINAL {
  $$ = regex_replace($NONTERMINAL.substr(1, $NONTERMINAL.length() - 2), regex{"[^a-zA-Z0-9_]"}, "_");
}
| TOKEN | LITERAL | NONTERMINAL COMMENT {
  $$ = regex_replace($NONTERMINAL.substr(1, $NONTERMINAL.length() - 2), regex{"[^a-zA-Z0-9_]"}, "_");
}
| TOKEN COMMENT
;

concatenation: production {
  $$ = $production;
}
| concatenation production {
  auto i = 0;
  for(const auto& v: $1) {
    for(const auto& w: $production) {
      auto joined = v;
      joined.insert(joined.end(), w.begin(), w.end());
      $$.insert(joined);
      ++i;
    }
  }
}
;

alternative: production_combos "|" concatenation {
  $$ = $production_combos;
  $$.merge($concatenation);
}

optional: "[" production_combos "]" {
  $$ = $production_combos;
  $$.merge(set<vector<string>>{{}});
}
;

// replace ellipsis repetition with new left-recursive rule to generate infinite sequences
repetition:
  element "..." {
  auto listRuleName = $element + "_list"s;
// left-recursive list rule for element elt
// elt_list: elt | elt_list elt
  bisonParam.result[listRuleName] = { {$element}, {listRuleName, $element} };
  $$ = { {listRuleName} };
}
| group "..." {
  string listRuleName;
  for(auto& v: $group) {
    for(auto& e: v) {
      listRuleName += e + "_";
    }
    listRuleName += "list";
    auto w = v;
    w.insert(w.begin(), listRuleName);
    bisonParam.result[listRuleName] = { v, w };
    $$.insert({listRuleName});
  }
}
| optional "..." {
}
;

group: "{" production_combos "}" {
  $$ = $production_combos;
}
;

header: %empty | header_lines

header_lines: HEADER_LINE | header_lines HEADER_LINE

// midrule action for postprocessing
postprocess: %empty {
  auto& b = bisonParam;
  auto& stats = b.stats;
  stats.parseEndTime = steady_clock::now();
  stats.parseTimeTakenSec = stats.parseEndTime - stats.parseStartTime;
  stats.numRulesGenerated = b.result.size();
}

%%

#ifdef BUILD_MAIN

#include <stdlib.h>
#include <stdio.h>
#include <getopt.h>

#include <string>
#include <iostream>
#include <memory>
#include <istream>
#include <fstream>

#include "lexer/ebnftobison_lexer.h"
#include "ebnftobison.bison.h"

using namespace std;
using namespace ebnftobison;

void usage() {
  puts("Usage: ebnftobison [-h | --help] [--debug] [file]");
  puts("ebnftobison converts extended EBNF as defined in Section 5.2 of the GQL ISO-39075:2024 standard to a Bison grammar");
  puts("");
  puts("Options:");
  puts("--debug: turns on Bison parser and Flex lexer debug traces, off by default");
  puts("--stats: print timing stats on successful parse, off by default");
  puts("--help | -h: prints usage help");
  puts("file: extended EBNF grammar file");
}

int main(int argc, char* argv[])
{
  ios_base::sync_with_stdio(false);

  bool debug{};
  bool printStats{};

// need filename pointer to stick around for bison error messages that print filename and position
  auto inputFilename = make_unique<string>("stdin");
  string changefile;

  option opts[] = {
    {"debug", no_argument, (int*)&debug, 1},
    {"stats", no_argument, (int*)&printStats, 1},
    {"help", no_argument, 0, 'h'},
    {0, 0, 0, 0}
  };

  for(int i, optLetter; (optLetter = getopt_long(argc, argv, "h", opts, &i)) != -1;) {
    switch(optLetter) {
    case 0:
      break;
    case 'h':
      usage();
      return 0;
    case '?':
      usage();
      return 1;
    default:
      break;
    }
  }

  Lexer lexer;

// set filename for bison error reporting
// switch input stream for lexer to read from file instead of default stdin
  ifstream fileStream;
  if(optind < argc) {
    *inputFilename = argv[optind];
    if(fileStream.open(*inputFilename); !fileStream) {
      fprintf(stderr, "error opening file \"%s\"\n", inputFilename->c_str());
      exit(1);
    }
    lexer.switch_streams(&fileStream);
  }

  location loc(inputFilename.get());
  BisonParam bisonParam;

  EbnfToBison parser([&lexer](location& loc) -> EbnfToBison::symbol_type {
    return lexer.yylex(loc);
  },
  bisonParam,
  loc);

  lexer.set_debug(debug);
  parser.set_debug_level(debug);

  if(auto ev = parser(); ev != 0) {
    fputs("parse failed\n", stderr);
    return ev;
  }

  if(printStats) {
    const auto& stats = bisonParam.stats;

    printf("parse_time %.9f secs, num_rules_parsed %lu, num_rules_generated %lu\n", stats.parseTimeTakenSec.count(), stats.numRulesParsed, stats.numRulesGenerated);
  }

  puts("");
  puts("result:");
  for(const auto& [rule, productions]: bisonParam.result) {
    printf("# %zu productions\n", productions.size());
    printf("%s:\n", rule.c_str());
    if(productions.empty()) {
      puts("");
      continue;
    }
    const auto& firstProduction = *productions.begin();
    for(const auto& elt: firstProduction) {
      printf("  %s", elt.c_str());
    }
    puts("");
    auto i = productions.begin();
    for(++i; i != productions.end(); ++i) {
      const auto& production = *i;
      printf("|");
      for(const auto& elt: production) {
        printf("  %s", elt.c_str());
      }
      puts("");
    }
    puts("");
  }
  
  return 0;
}

#endif
